// Code generated by protoc-gen-tarp. DO NOT EDIT. haberdasher

import 'dart:convert';
import 'dart:io';

import 'package:protobuf/protobuf.dart';
import 'package:tart/twirp.dart' as twirp;
import 'haberdasher.pb.dart';
import 'suit.pb.dart';


/// Haberdasher service makes hats for clients.
abstract class Haberdasher {
  /// MakeHat produces a hat of mysterious, randomly-selected color!
  Future<Hat> makeHat(twirp.Context ctx, Size req);
  /// MakeSuit produces a suit of perfect proportions, with random color
  Future<Suit> makeSuit(twirp.Context ctx, SuitSizeReq req);
}

/// Haberdasher service makes hats for clients.
class HaberdasherJSONClient implements Haberdasher {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  HaberdasherJSONClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<Hat> makeHat(twirp.Context ctx, Size req) async {
    ctx = twirp.withPackageName(ctx, 'protos');
    ctx = twirp.withServiceName(ctx, 'Haberdasher');
    ctx = twirp.withMethodName(ctx, 'MakeHat');
    return interceptor((ctx, req) {
      return callMakeHat(ctx, req);
    })(ctx, req);
  }

  Future<Hat> callMakeHat(twirp.Context ctx, Size req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'protos.Haberdasher/MakeHat');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final Hat res = Hat.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<Suit> makeSuit(twirp.Context ctx, SuitSizeReq req) async {
    ctx = twirp.withPackageName(ctx, 'protos');
    ctx = twirp.withServiceName(ctx, 'Haberdasher');
    ctx = twirp.withMethodName(ctx, 'MakeSuit');
    return interceptor((ctx, req) {
      return callMakeSuit(ctx, req);
    })(ctx, req);
  }

  Future<Suit> callMakeSuit(twirp.Context ctx, SuitSizeReq req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'protos.Haberdasher/MakeSuit');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final Suit res = Suit.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}

/// Haberdasher service makes hats for clients.
class HaberdasherProtobufClient implements Haberdasher {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  HaberdasherProtobufClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl + '/';
    if (!prefix.endsWith('/')) baseUrl + '/';
    if (prefix.startsWith('/')) baseUrl = baseUrl.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<Hat> makeHat(twirp.Context ctx, Size req) async {
    ctx = twirp.withPackageName(ctx, 'protos');
    ctx = twirp.withServiceName(ctx, 'Haberdasher');
    ctx = twirp.withMethodName(ctx, 'MakeHat');
    return interceptor((ctx, req) {
      return callMakeHat(ctx, req);
    })(ctx, req);
  }

  Future<Hat> callMakeHat(twirp.Context ctx, Size req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'protos.Haberdasher/MakeHat');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final Hat res = Hat.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<Suit> makeSuit(twirp.Context ctx, SuitSizeReq req) async {
    ctx = twirp.withPackageName(ctx, 'protos');
    ctx = twirp.withServiceName(ctx, 'Haberdasher');
    ctx = twirp.withMethodName(ctx, 'MakeSuit');
    return interceptor((ctx, req) {
      return callMakeSuit(ctx, req);
    })(ctx, req);
  }

  Future<Suit> callMakeSuit(twirp.Context ctx, SuitSizeReq req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'protos.Haberdasher/MakeSuit');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final Suit res = Suit.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}

Future<List<int>> doProtobufRequest(twirp.Context ctx, Uri url, twirp.ClientHooks hooks, GeneratedMessage req) async {
  // setup http client
  HttpClient httpClient = HttpClient();

  try {
    // setup request
    HttpClientRequest httpClientRequest = await httpClient.post(url.host, url.port, url.path);

    // add required headers
    httpClientRequest.headers.add(HttpHeaders.acceptHeader, 'application/protobuf');
    httpClientRequest.headers.add(HttpHeaders.contentTypeHeader, 'application/protobuf');

    // add headers from context
    final headersFromCtxVal = twirp.retrieveHttpRequestHeaders(ctx);
    if (!headersFromCtxVal.hasError()) {
      headersFromCtxVal.getValue().forEach((key, value) {
        httpClientRequest.headers.add(key, value);
      });
    }

    // call onRequestPrepared hook for user to modify request
    hooks.onRequestPrepared(ctx, httpClientRequest);

    // send data
    httpClientRequest.add(req.writeToBuffer());

    // close request and receive response
    HttpClientResponse httpClientResponse = await httpClientRequest.close();

    // if success, parse and return response
    if (httpClientResponse.statusCode == 200) {
      List<int> data = <int>[];
      await httpClientResponse.listen((event) {
        data.addAll(event);
      }).asFuture();
      hooks.onResponseReceived(ctx);
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.Error.fromJson(
        json.decode(await httpClientResponse.transform(utf8.decoder).join()));
  } on twirp.Error catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error
    final twirpErr = twirp.Error.fromConnectionError(e.toString());
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

Future<String> doJSONRequest(twirp.Context ctx, Uri url, twirp.ClientHooks hooks, GeneratedMessage req) async {
  // setup http client
  HttpClient httpClient = HttpClient();

  try {
    // setup request
    HttpClientRequest httpClientRequest = await httpClient.post(url.host, url.port, url.path);

    // add required headers
    httpClientRequest.headers.add(HttpHeaders.acceptHeader, 'application/json');
    httpClientRequest.headers.add(HttpHeaders.contentTypeHeader, 'application/json');

    // add headers from context
    final headersFromCtxVal = twirp.retrieveHttpRequestHeaders(ctx);
    if (!headersFromCtxVal.hasError()) {
      headersFromCtxVal.getValue().forEach((key, value) {
        httpClientRequest.headers.add(key, value);
      });
    }

    // call onRequestPrepared hook for user to modify request
    hooks.onRequestPrepared(ctx, httpClientRequest);

    // send data
    httpClientRequest.write(json.encode(req.toProto3Json()));

    // close request and receive response
    HttpClientResponse httpClientResponse = await httpClientRequest.close();

    // if success, parse and return response
    if (httpClientResponse.statusCode == 200) {
      final data = await httpClientResponse.transform(utf8.decoder).join().then((data) {
        hooks.onResponseReceived(ctx);
        // res.mergeFromProto3Json(json.decode(data));
        return data;
      });
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.Error.fromJson(json.decode(await httpClientResponse.transform(utf8.decoder).join()));
  } on twirp.Error catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error
    final twirpErr = twirp.Error.fromConnectionError(e.toString());
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}
